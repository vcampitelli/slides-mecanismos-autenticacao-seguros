<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="author" content="Vinícius Campitelli">
        <meta name="description" content="Uma das partes mais básicas de um sistema é seu processo de login. E por ser algo que não agrega valor direto ao negócio, acabamos não gastando o tempo necessário para criar um fluxo realmente seguro, fazendo com que ele se torne o principal vetor de ataques de nossa aplicação. Iremos aprender como criar mecanismos seguros de autenticação, utilizando CSRF de forma correta, CAPTCHA, duplo fator de autenticação, prevenção à enumeração de usuários e outras técnias para dificultar ataques. Veremos também diversas dicas de como implementar as arriscadas (mas muitas vezes necessárias) funções 'Permanecer logado' e 'Esqueci a senha'.">

        <title>Criando mecanismos de autenticação seguros</title>

        <link rel="stylesheet" href="reveal.js/css/reveal.css">
        <link rel="stylesheet" href="reveal.js/css/theme/moon.css">
        <link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700,700i&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/prism.css">
        <link rel="stylesheet" href="css/app.css">

        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'reveal.js/' + (window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css');
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>Criando mecanismos de autenticação seguros</h1>
                </section>

                <section>
                    <h2>Quem sou eu?</h2>
                    <ul>
                        <li>Vinícius Campitelli &mdash; <a href="http://vcampitelli.github.io">vcampitelli.github.io</a></li>
                        <li>Arquiteto na <a href="https://mt4.com.br" target="_blank">MT4 Tecnologia</a></li>
                        <li>Sócio-fundador no <a href="https://curseduca.pro" target="_blank">Curseduca</a></li>
                    </ul>
                </section>

                <section>
                    <h2>Agenda</h2>
                    <ul class="no-padding">
                        <li>Protegendo CSRF de forma correta;</li>
                        <li>CAPTCHA;</li>
                        <li>Duplo fator de autenticação;</li>
                        <li>Prevenção à enumeração de usuários;</li>
                        <li>Outras técnicas para dificultar ataques;</li>
                        <li>Funcionalidade "Permanecer logado";</li>
                        <li>Funcionalidade "Esqueci a senha".</li>
                    </ul>
                </section>

                <section>
                    <section>
                        <h2>Protegendo CSRF de forma correta</h2>
                    </section>
                    <section>
                        <h3>Definição</h3>
                        <p>Cross-site request forgery</p>
                        <p class="fragment">"Falsificação de requisição entre sites"</p>
                    </section>
                    <section>
                        <h3>O que é na prática?</h3>
                        <ul>
                            <li class="fragment">Imagine que você esteja logado em um site <code>site1.com</code> <em>(ou seja, com um cookie válido)</em></li>
                            <li class="fragment">E também acessa o site <code>site2.com</code></li>
                            <li class="fragment">E no site <code>site2.com</code>, há uma requisição <code>POST site1.com/sacar account=abc&amount=1000</code></li>
                            <li class="fragment">Como você está autenticado no site1, ele irá reconhecer essa como sendo uma requisição válida</li>
                            <li class="fragment">E você irá perder seu precioso dinheiro!</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Como se proteger?</h3>
                        <ul>
                            <li class="fragment">Quando o usuário autentica em seu sistema, gere um <em>token</em> para ele e guarde-o na sessão</li>
                            <li class="fragment">Em cada página que origina uma ação de alteração de estado em seu sistema, coloque esse <em>token</em> junto da requisição (em campos do formulário ou cabeçalhos do AJAX)</li>
                            <li class="fragment">Na página que recebe a ação, verifique se o <em>token</em> enviado é válido</li>
                            <li class="fragment">Pronto! Você tem o básico de uma proteção de CSRF em seu sistema</li>
                        </ul>
                    </section>
                    <section>
                        <h3>E como se proteger mais ainda?</h3>
                        <ul>
                            <li class="fragment">Ao invés de injetar diretamente o <em>token</em> em campos do HTML, você pode passá-lo através de cabeçalhos HTTP</li>
                            <li class="fragment">Crie uma sessão "falsa" na tela de login para garantir que um atacante não faça um usuário passar-se por ele</li>
                            <li class="fragment">Atributo <code>Samesite</code> de Cookies</li>
                            <li class="fragment">Verifique o cabeçalho <code>Referer</code> (ou <code>Origin</code>) da requisição HTTP para garantir que a origem é do seu mesmo site</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Premissas e recomendações</h3>
                        <ul>
                            <li class="fragment">O <em>token</em> não pode se repetir entre usuários diferentes, então é importante utilizar um CSPRNG <em>(Cryptographically Secure Pseudo-Random Number Generator)</em></li>
                            <li class="fragment">Não pode ser muito pequeno <em>(para evitar brute force)</em></li>
                            <li class="fragment">Não pode aparecer nos <em>logs</em> do servidor</li>
                            <li class="fragment">Não pode estar na URL</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Premissas e recomendações <small>(continuação)</small></h3>
                        <ul>
                            <li class="fragment">Você <em>pode</em> gerar <em>tokens</em> a cada requisição ao invés de um por sessão, mas isso interfere na usabilidade do sistema (por exemplo, o botão <em>Voltar</em> do navegador irá causar uma falha de CSRF)</li>
                            <li class="fragment">Se você quiser uma abordagem <em>stateless</em>, pode gerar um <em>token</em> criptografado com o <code>Session ID</code> do usuário e um <em>timestamp</em>, por exemplo</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Referências</h3>
                        <ul>
                            <li><a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.md" target="_blank">OWASP CheatSheet de prevenção de CSRF</a></li>
                            <li><a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">Paper "Robust Defenses for Cross-Site Request Forgery" de Stanford</a></li>
                        </ul>
                        <br><br>
                        <h3>Bibliotecas</h3>
                        <ul>
                            <li><a href="https://github.com/symfony/security-csrf" target="_blank">symfony/security-csrf</a></li>
                            <li><a href="https://github.com/paragonie/anti-csrf" target="_blank">paragonie/anti-csrf</a></li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>CAPTCHA</h2>
                    </section>
                    <section>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Duplo fator de autenticação</h2>
                    </section>
                    <section>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Prevenção à enumeração de usuários</h2>
                    </section>
                    <section>
                        O que um sistema que rode o código a seguir pode dar de informação a um atacante?
                    </section>
                    <section>
                        <pre><code class="language-php line-numbers">public function login(string $username, string $password) : bool
{
    $user = $this->findByUsername($username);
    if (! $user) {
        return false;
    }
    return $this->verifyPassword($password, $user->getPassword());
}</code></pre>
                    </section>
                    <section>
                        <p>É possível saber que usuários existem em sua aplicação através de <em>timing attack</em></p>
                        <p class="fragment">Modifique o código para que a custosa função <code>verifyPassword</code> seja sempre invocada!</p>
                    </section>
                    <section>
                        <pre><code class="language-php line-numbers">public function login(string $username, string $password) : bool
{
    $storedPassword = $this->generateFakePassword();
    $user = $this->findByUsername($username);
    if ($user) {
        $storedPassword = $user->getPassword();
    }
    return ($this->verifyPassword($password, $storedPassword))
        && ($user !== null);
}</code></pre>
                    </section>
                    <section>
                        <p>Será que não estamos exagerando?<br>É realmente possível ver essa diferença?</p><br>
                        <p class="fragment">
                            Vamos testar, então!<br><br>
                            <small>Executando os scripts <code>login-user-enumeration.php</code><br>e <code>login-user-enumeration-fixed.php</code></small>
                        </p>
                    </section>
                    <section>
                        <video controls>
                            <source src="scripts/login-user-enumeration.mp4">
                        </video>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Outras técnicas para dificultar ataques</h2>
                    </section>
                    <section>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Funcionalidade "Permanecer logado"</h2>
                    </section>
                    <section>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Funcionalidade "Esqueci a senha"</h2>
                    </section>
                    <section>
                    </section>
                </section>
            </div>
        </div>

        <script src="reveal.js/js/reveal.js"></script>
        <script>
            Reveal.initialize({
                dependencies: [
                    { src: 'js/prism.js', async: true }
                ],
                transition: 'convex',
                slideNumber: true,
                mouseWheel: false,
                history: true,
                overview: false
            });
        </script>
    </body>
</html>
