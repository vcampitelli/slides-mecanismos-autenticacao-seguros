<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="author" content="Vinícius Campitelli">
        <meta name="description" content="Uma das partes mais básicas de um sistema é seu processo de login. E por ser algo que não agrega valor direto ao negócio, acabamos não gastando o tempo necessário para criar um fluxo realmente seguro, fazendo com que ele se torne o principal vetor de ataques de nossa aplicação. Iremos aprender como criar mecanismos seguros de autenticação, utilizando CSRF de forma correta, CAPTCHA, duplo fator de autenticação, prevenção à enumeração de usuários e autenticação em APIs. Veremos também diversas dicas de como implementar as arriscadas (mas muitas vezes necessárias) funções 'Permanecer logado' e 'Esqueci a senha'.">

        <title>Criando mecanismos de autenticação seguros</title>

        <link rel="stylesheet" href="reveal.js/css/reveal.css">
        <link rel="stylesheet" href="reveal.js/css/theme/moon.css">
        <link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700,700i&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/prism.css">
        <link rel="stylesheet" href="css/app.css">

        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'reveal.js/' + (window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css');
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>Criando mecanismos de autenticação seguros</h1>
                </section>

                <section>
                    <h2>Quem sou eu?</h2>
                    <ul>
                        <li>Vinícius Campitelli &mdash; <a href="http://vcampitelli.github.io">vcampitelli.github.io</a></li>
                        <li>Arquiteto na <a href="https://mt4.com.br" target="_blank">MT4 Tecnologia</a></li>
                        <li>Sócio-fundador no <a href="https://curseduca.pro" target="_blank">Curseduca</a></li>
                    </ul>
                </section>

                <section>
                    <h2>Agenda</h2>
                    <ul class="no-padding">
                        <li>Protegendo CSRF de forma correta;</li>
                        <li>CAPTCHA;</li>
                        <li>Duplo fator de autenticação;</li>
                        <li>Prevenção à enumeração de usuários;</li>
                        <li>Funcionalidade "Permanecer logado";</li>
                        <li>Funcionalidade "Esqueci a senha".</li>
                        <li>Autenticação em APIs;</li>
                    </ul>
                </section>

                <section>
                    <section>
                        <h2>Protegendo CSRF de forma correta</h2>
                    </section>
                    <section>
                        <h3>Definição</h3>
                        <p>Cross-site request forgery</p>
                    </section>
                    <section>
                        <h3>O que é na prática?</h3>
                        <ul>
                            <li class="fragment">Imagine que você esteja logado em um site <code>site1.com</code> <em>(ou seja, com um cookie válido)</em></li>
                            <li class="fragment">E também acessa o site <code>site2.com</code></li>
                            <li class="fragment">E no site <code>site2.com</code>, há uma requisição <code>POST site1.com/sacar account=abc&amount=1000</code></li>
                            <li class="fragment">Como você está autenticado no site1, ele irá reconhecer essa como sendo uma requisição válida</li>
                            <li class="fragment">E você irá perder seu precioso dinheiro!</li>
                        </ul>
                    </section>
                    <section>
                        Preciso disso na tela de login? Sim, para garantir que um atacante não faça um usuário passar-se por ele
                    </section>
                    <section>
                        <h3>Como se proteger?</h3>
                        <ul>
                            <li class="fragment">Crie uma sessão "falsa"</li>
                            <li class="fragment">Gere um <em>token</em> para ele e guarde-o nessa sessão</li>
                            <li class="fragment">Coloque esse <em>token</em> junto da requisição (em campos do formulário ou cabeçalhos do AJAX)</li>
                            <li class="fragment">Na página que recebe a ação de login, verifique se o <em>token</em> enviado é válido</li>
                            <li class="fragment">Pronto! Você tem o básico de uma proteção de CSRF em seu sistema</li>
                        </ul>
                    </section>
                    <section>
                        <h3>E como se proteger mais ainda?</h3>
                        <ul>
                            <li class="fragment"><a href="https://ayesh.me/PHP-Samesite-cookies" target="_blank">Atributo <code>Samesite</code></a> de Cookies</li>
                            <li class="fragment">Verifique o cabeçalho <code>Referer</code> (ou <code>Origin</code>) da requisição HTTP para garantir que a origem é do seu mesmo site</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Premissas e recomendações</h3>
                        <ul>
                            <li class="fragment">O <em>token</em> não pode se repetir entre usuários diferentes, então é importante utilizar um <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" target="_blank">CSPRNG</a> <em>(Cryptographically Secure Pseudo-Random Number Generator)</em></li>
                            <li class="fragment">Não pode ser muito pequeno <em>(para evitar brute force)</em></li>
                            <li class="fragment">Não pode aparecer nos <em>logs</em> do servidor</li>
                            <li class="fragment">Não pode estar na URL</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Premissas e recomendações <small>(continuação)</small></h3>
                        <ul>
                            <li class="fragment">Você <em>pode</em> gerar <em>tokens</em> a cada requisição ao invés de um por sessão, mas isso interfere na usabilidade do sistema (por exemplo, o botão <em>Voltar</em> do navegador irá causar uma falha de CSRF)</li>
                            <li class="fragment">Se você quiser uma abordagem <em>stateless</em>, pode gerar um <em>token</em> criptografado com o <code>Session ID</code> do usuário e um <em>timestamp</em>, por exemplo</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Referências</h3>
                        <ul>
                            <li><a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.md" target="_blank">OWASP CheatSheet de prevenção de CSRF</a></li>
                            <li><a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">Paper "Robust Defenses for Cross-Site Request Forgery" de Stanford</a></li>
                        </ul>
                        <br><br>
                        <h3>Bibliotecas</h3>
                        <ul>
                            <li><a href="https://github.com/symfony/security-csrf" target="_blank">symfony/security-csrf</a></li>
                            <li><a href="https://github.com/paragonie/anti-csrf" target="_blank">paragonie/anti-csrf</a></li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>CAPTCHA</h2>
                    </section>
                    <section>
                        <h3>Definição</h3>
                        <div class="div-center">
                            <strong>C</strong>ompletely<br>
                            <strong>A</strong>utomated<br>
                            <strong>P</strong>ublic<br>
                            <strong>T</strong>uring test to tell<br>
                            <strong>C</strong>omputers and<br>
                            <strong>H</strong>umans<br>
                            <strong>A</strong>part
                        </div>
                    </section>
                    <section>
                        <h3>Referências</h3>
                        <ul>
                            <li><a href="https://www.google.com/recaptcha/intro/v3.html" target="_blank">reCAPTCHA v3</a></li>
                            <li><a href="https://www.phpcaptcha.org" target="_blank">Securimage PHP CAPTCHA</a></li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Duplo fator de autenticação</h2>
                    </section>
                    <section>
                        <h3>HOTP</h3>
                        <ul>
                            <li><a href="https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_algorithm" target="_blank"><strong>H</strong>MAC-based <strong>O</strong>ne-<strong>T</strong>ime <strong>P</strong>assword</a> é um algoritmo
                            baseado em <a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code" target="_blank">HMAC</a> que gera uma senha a partir de uma chave</li>
                            <li class="fragment">Para garantir a unicidade <em>(afinal, há One-Time no nome)</em>, é incrementado um contador a cada geração/checagem do valor</li>
                        </ul>
                    </section>
                    <section>
                        <h3>TOTP</h3>
                        <ul>
                            <li><a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm" target="_blank"><strong>T</strong>ime-based <strong>O</strong>ne-<strong>T</strong>ime <strong>P</strong>assword</a> é uma extensão do
                                HOTP, que utiliza o horário atual ao invés do contador para a unicidade</li>
                            <li class="fragment">Geralmente, há uma janela de 30 segundos de validade da senha</li>
                        </ul>
                    </section>
                    <section>
                        <pre><code class="language-php line-numbers">public function __construct() {
    $this->authenticator = new \Sonata\GoogleAuthenticator\GoogleAuthenticator();
    $this->secret = getAuthenticatorSecretFromSomewhere();
}

public function check(string $code) : bool {
    return $this->authenticator->checkCode($this->secret, $code);
}

public fuction generateSecret() : string {
    return $this->authenticator->generateSecret()
}

public fuction generateSecret(string $secret) : string {
    return \Sonata\GoogleAuthenticator\GoogleQrUrl::generate(
        'My App',
        $secret
    );
}</code></pre>
                    </section>
                    <section>
                        <h3>Referências, bibliotecas e soluções</h3>
                        <ul>
                            <li><a href="https://sakurity.com/blog/2015/07/18/2fa.html" target="_blank">Why You Don't Need 2 Factor Authentication</a></li>
                            <li><a href="https://www.kaspersky.com/blog/2fa-practical-guide/24219/" target="_blank">SMS-based two-factor authentication is not safe</a></li>
                            <li><a href="https://github.com/sonata-project/GoogleAuthenticator" target="_blank">sonata-project/google-authenticator</a></li>
                            <li><a href="https://github.com/twilio/authy-php" target="_blank">twilio/authy-php</a></li>
                            <li><a href="https://www.twilio.com/sms" target="_blank">Twilio SMS</a></li>
                            <li><a href="https://www.nexmo.com/products/sms" target="_blank">Nexmo SMS</a></li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Prevenção à enumeração de usuários</h2>
                    </section>
                    <section>
                        O que um sistema que rode o código a seguir pode dar de informação a um atacante?
                    </section>
                    <section>
                        <pre><code class="language-php line-numbers">public function login(string $username, string $password) : bool
{
    $user = $this->findByUsername($username);
    if (! $user) {
        return false;
    }
    return $this->verifyPassword($password, $user->getPassword());
}</code></pre>
                    </section>
                    <section>
                        <p>É possível saber que usuários existem em sua aplicação através de <em>timing attack</em></p>
                        <p class="fragment">Modifique o código para que a custosa função <code>verifyPassword</code> seja sempre invocada!</p>
                    </section>
                    <section>
                        <pre><code class="language-php line-numbers">public function login(string $username, string $password) : bool
{
    $storedPassword = $this->generateFakePassword();
    $user = $this->findByUsername($username);
    if ($user) {
        $storedPassword = $user->getPassword();
    }
    return ($this->verifyPassword($password, $storedPassword))
        && ($user !== null);
}</code></pre>
                    </section>
                    <section>
                        <p>Será que não estamos exagerando?<br>É realmente possível ver essa diferença?</p><br>
                        <p class="fragment">
                            Vamos testar, então!<br><br>
                            <small>Executando os scripts <code>login-user-enumeration.php</code><br>e <code>login-user-enumeration-fixed.php</code></small>
                        </p>
                    </section>
                    <section>
                        <video controls>
                            <source src="scripts/login-user-enumeration.mp4">
                        </video>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Funcionalidade "Permanecer logado"</h2>
                    </section>
                    <section>
                        <h3>Solução mais simples</h3>
                        <ul>
                            <li class="fragment">Gerar um <em>token</em> único</li>
                            <li class="fragment">Guardá-lo no <em>cookie</em> do browser do usuário</li>
                            <li class="fragment">Salvar esse <em>token</em> em um banco de dados relacionando ao usuário</li>
                            <li class="fragment">Sempre que é feito o acesso à tela de login, comparar os tokens</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Cuidados</h4>
                        <ul>
                            <li class="fragment">Garanta que o <em>token</em> será único para o usuário e não previsível (novamente, use <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" target="_blank">CSPRNG</a>)</li>
                            <li class="fragment">Faça comparações que tenham tempo fixo para prevenir <em>timing attacks</em> (por exemplo, <code>hash_equals()</code>)</li>
                            <li class="fragment">Precisa ser eficiente, para não permitir <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank">DoS</a></li>
                        </ul>
                    </section>
                    <section>
                        <h3 id="remember-me-good-solution">Solução mais segura</h3>
                        <ul>
                            <li class="fragment">Prefixe o <em>token</em> com um <strong>identificador</strong> <strong class="fragment">(NÃO use diretamente o ID do usuário)</strong></li>
                            <li class="fragment">Crie uma tabela no banco de dados com o identificador acima e apenas o <em>hash</em> do <em>token (SHA-256 ou melhor)</em></li>
                            <li class="fragment">Ao consultar a tabela, utilize apenas o identificador na Query</li>
                            <li class="fragment">Faça o <em>hash</em> do <em>token</em> informado no <em>cookie</em> do usuário e compare-o com o que está no banco (novamente, com <code>hash_equals()</code>)</li>
                            <li class="fragment">Não esqueça de invalidar os <em>tokens</em> do usuário se ele trocar a senha</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Referência</h3>
                        <ul>
                            <li><a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2.1" target="_blank">"Remember Me" - Long-Term Persistent Authentication (Paragon IE)</a></li>
                        </ul>
                        <h3>Biblioteca</h3>
                        <ul>
                            <li><a href="https://github.com/psecio/gatekeeper" target="_blank">psecio/gatekeeper</a></li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Funcionalidade "Esqueci a senha"</h2>
                    </section>
                    <section>
                        <h3>Precauções</h3>
                        <ul>
                            <li class="fragment">Perguntas secretas estão cada vez menos secretas por causa das redes sociais</li>
                            <li class="fragment">Emails não são sempre encriptados</li>
                            <li class="fragment">Emails podem não chegar</li>
                            <li class="fragment"><a href="https://medium.com/@vasanthavanan59439/ss7-the-deadliest-attack-6423de7fe8c0" target="_blank">SMS não são confiáveis</a></li>
                    </section>
                    <section>
                        <h3><span class="fragment">Tentativa de</span> Solução</h3>
                        <ul>
                            <li class="fragment">Realmente avalie se seu sistema precisa dessa funcionalidade automática</li>
                            <li class="fragment"><strong>NÃO</strong> crie uma nova senha e envie por email</li>
                            <li class="fragment"><strong>NÃO</strong> mande a senha em texto plano por email <em>(?????)</em></li>
                            <li class="fragment">Utilize a <a href="#remember-me-good-solution">mesma solução</a> do <em>token</em> descrita no slide de "Permanecer logado"</li>
                            <li class="fragment">Coloque um tempo limite para expiração do <em>token></em></li>
                            <li class="fragment">Envie o código para o usuário (se for por email, criptografe!)</li>
                            <li class="fragment">Se o usuário fornecer um usuário que não existe na base, <strong>não</strong> o avise!</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Referências</h3>
                        <ul>
                            <li><a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2.1" target="_blank">Account Recovery (Paragon IE)</a></li>
                            <li><a href="https://paragonie.com/blog/2016/09/untangling-forget-me-knot-secure-account-recovery-made-simple" target="_blank">Untangling the Forget-Me Knot: Secure Account Recovery Made Simple</a></li>
                        </ul>
                        <h3>Biblioteca</h3>
                        <ul>
                            <li><a href="https://github.com/paragonie/gpg-mailer" target="_blank">paragonie/gpg-mailer</a></li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Autenticação em APIs</h2>
                    </section>
                    <section>
                        <ul>
                            <li class="fragment">Use HTTPS sempre (&hearts; <a href="https://letsencrypt.org" target="_blank">Let's Encrypt</a>)</li>
                            <li class="fragment">Não crie seu próprio sistema de autenticação, utilize um protocolo já conhecido (<a href="https://openid.net/connect/" target="_blank">OpenID</a>, <a href="https://oauth2.thephpleague.com" target="_blank">OAuth 2.0</a>, entre outros)</li>
                            <li class="fragment">Para <em>tokens</em>, utilize <a href="https://jwt.io" target="_blank">JWT</a> ou <a href="https://github.com/paragonie/paseto" target="_blank">Paseto</a></li>
                            <li class="fragment">Se for usar JWT, garanta que seu sistema não permita um <code>algorithm=none</code></li>
                            <li class="fragment">Para geração dos identificadores do usuário <em>(por exemplo, client secret no OAuth 2)</em> utilize <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" target="_blank">CSPRNG</a></li>
                            <li class="fragment">Mesmo se usar um <a href="https://www.nginx.com/learn/api-gateway/" target="_blank">API Gateway</a>, não deixe seus microserviços sem autenticação. Repasse o token para todos!</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Referências</h3>
                        <ul>
                            <li><a href="https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/" target="_blank">Critical vulnerabilities in JSON Web Token libraries</a></li>
                            <li><a href="https://auth0.com/learn/token-based-authentication-made-easy/" target="_blank">Token Based Authentication Made Easy</a></li>
                        </ul>
                        <h3>Bibliotecas</h3>
                        <ul>
                            <li><a href="https://github.com/lcobucci/jwt" target="_blank">lcobucci/jwt</a></li>
                            <li><a href="https://github.com/thephpleague/oauth2-server" target="_blank">thephpleague/oauth2-server</a></li>
                        </ul>
                    </section>
                </section>
            </div>
        </div>

        <script src="reveal.js/js/reveal.js"></script>
        <script>
            Reveal.initialize({
                dependencies: [
                    { src: 'js/prism.js', async: true }
                ],
                transition: 'convex',
                slideNumber: true,
                mouseWheel: false,
                history: true,
                overview: false
            });
        </script>
    </body>
</html>
